package proginscala.chapter8

/** A partial applied function is an expression in which you don't supply all of the arguments needed by the function.
  * Instead, you supply some, or none, of the needed arguments.
  */
object PartialFunction extends App:

  def sum(a: Int, b: Int, c: Int) = a + b + c

  /** To create a partially applied function expression, in which you supply none of the three required arguments, you
    * could use an underscore (_) for each parameter:
    *
    * What happened behind:
    *   - x refers to a function value object which is an instance of a class generated automatically by the Scala
    *     compiler from sum(_, _, _), the partially applied function
    *   - the class generated by the compiler has an apply method that takes three arguments because three is the number
    *     of arguments missing in the sum(_, _, _) expression
    *   - the Scala compiler translates the expression x(1, 2, 3) into an invocation of the function value's apply
    *     method, passing in the actual arguments
    */
  val x = sum(_, _, _) // type: (Int, Int, Int) => Int
  println(s"x = $x")
  println(s"x(1, 2, 3) = ${x(1, 2, 3)}")
  println(s"x.apply(1, 2, 3) = ${x.apply(1, 2, 3)}")

  // You can create partial functions by supplying some of the required arguments
  // The Scala compiler generates a new function class whose apply method takes one argument.
  val y = sum(1, _, 3)
  println(s"y(2) = ${y(2)}")
  println(s"y(7) = ${y.apply(7)}")

  // If you leave off all parameters in the partially applied function, you can express it more
  //  concisely by leaving off the entire parameter list.
  val z = sum
  println(s"z(3, 4, 5) = ${z(3, 4, 5)}")
